'use strict';

// -----------------------------------------------------------------
//  This stub Zome code file was auto-generated by hc-scaffold
// -----------------------------------------------------------------

// Helper functions:
function anchor(anchorType, anchorText) {
  return call('anchors', 'anchor', {
    anchorType: anchorType,
    anchorText: anchorText
  }).replace(/"/g, '');
}

function anchorExists(anchorType, anchorText) {
  return call('anchors', 'exists', {
    anchorType: anchorType,
    anchorText: anchorText
  });
}

// -----------------------------------------------------------------
//  Exposed functions with custom logic https://developer.holochain.org/API_reference
// -----------------------------------------------------------------

function eventCreate (eventEntry) {
  var eventHash = commit("event", eventEntry);

  var eventAnchor = anchor('event', eventHash);

  return eventHash;
}

function eventRead (eventHash) {
  var event = get(eventHash);
  return event;
}

function eventUpdate (updateObject) {
  var eventHash = updateObject.eventHash
  var updatedValue = updateObject.updatedValue

  var eventOutHash = update("event", updatedValue, eventHash);

  return eventOutHash;
}

function limitOrderCreate (limitOrderEntry) {

  debug("limitOrderEntry: " + JSON.stringify(limitOrderEntry))
  var limitOrderHash = commit("limitOrder", limitOrderEntry);


  var userOrderLinkHash = commit('userOrderLink', {
      Links: [
        {
          Base: App.Agent.Hash,
          Link: limitOrderHash,
          Tag: 'userOrder'
        }
      ]
    })

  var eventOrderLinkHash = commit('eventOrderLink', {
      Links: [
        {
          Base: limitOrderEntry.eventID,
          Link: limitOrderHash,
          Tag: 'eventOrder'
        }
      ]
    })

  var event = get(limitOrderEntry.eventID)
  debug("event: " + JSON.stringify(event))

  return limitOrderHash;
}

function limitOrderRead (limitOrderHash) {
  var limitOrder = get(limitOrderHash);
  return limitOrder;
}

function setEventOutcome (eventHash, eventOutcome) {
  // your custom code here
  var event = eventRead(eventHash)
  event.outcome = eventOutcome
  event.hasOutcome = true

  var newEventHash = eventUpdate({"eventHash": eventHash, "updatedEvent": event})

  return newEventHash;
}

function getBalance () {
  // your custom code here
  var me = Apps.Agent.Hash

  var orders = getLinks(me, 'userOrders', { Load: true })

  var balance = 100

  /// lots of math


  return balance;
}


// -----------------------------------------------------------------
//  The Genesis Function https://developer.holochain.org/genesis
// -----------------------------------------------------------------

/**
 * Called only when your source chain is generated
 * @return {boolean} success
 */
function genesis () {
  return true;
}

// -----------------------------------------------------------------
//  Validation functions for every change to the local chain or DHT
// -----------------------------------------------------------------

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateCommit (entryName, entry, header, pkg, sources) {
  switch (entryName) {
    case "event":

      // Date greater than today
      var endDate = new Date(entry.endDate)
      var currentDate = new Date()
      if (endDate < currentDate)                                           return false

      // hasOutcome not set if still running
      if (endDate >= currentDate && entry.hasOutcome)                      return false

      return true;
    case "limitOrder":
      if (entry.limit < 0 || entry.limit > 100)                            return false
      if (entry.amount < 0 || entry.amount > 1000000)                      return false
      if (entry.amountExecuted <0 || entry.amountExecuted > entry.amount)  return false

      // Ensure Event exists
      if (!anchorExists('event', entry.eventID))                           return false

      // ensure Event end Date isn't past
      // var event = getAnchor('event', entry.eventID)
      // var endDate = new Date(event.endDate)
      // var currentDate = new Date()
      // if (endDate < currentDate)                                           return false

      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validatePut (entryName, entry, header, pkg, sources) {
  switch (entryName) {
    case "event":

      // Date greater than today
      // var endDate = new Date(entry.endDate)
      // var currentDate = get(entry, { GetMask: HC.GetMask.Sources })
      // debug('###########sources of eventCreate' + currentDate)
      // if (endDate < currentDate)                                           return false

      // hasOutcome not set if still running
      // if (endDate >= currentDate && entry.hasOutcome)                      return false

      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "limitOrder":

      if (entry.limit < 0 || entry.limit > 100)                            return false
      if (entry.amount < 0 || entry.amount > 1000000)                      return false
      if (entry.amountExecuted <0 || entry.amountExecuted > entry.amount)  return false

      // Ensure Event exists
      if (!anchorExists('event', entry.eventID))                           return false

      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {string} replaces - the hash for the entry being updated
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateMod (entryName, entry, header, replaces, pkg, sources) {
  switch (entryName) {
    case "event":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "limitOrder":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {string} hash - the hash of the entry to remove
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateDel (entryName, hash, pkg, sources) {
  switch (entryName) {
    case "event":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "limitOrder":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {string} baseHash - the hash of the base entry being linked
 * @param {?} links - ?
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateLink (entryName, baseHash, links, pkg, sources) {
  switch (entryName) {
    case "event":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "limitOrder":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validatePutPkg (entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateModPkg (entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateDelPkg (entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateLinkPkg (entryName) {
  return null;
}